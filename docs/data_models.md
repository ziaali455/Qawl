# Qawl Data Models & Database Schema

*Last updated: Jul 3 2025*  
*Generated by AI*

## Overview

This document describes the core data models in the Qawl application and their relationships within the Firebase Firestore database. The application uses a NoSQL document-based structure with collections for users, tracks, and playlists.

## Database Collections

### 1. QawlUsers Collection

**Collection Path**: `QawlUsers/{userId}`

**Document Structure**:
```json
{
  "uid": "string",
  "email": "string",
  "name": "string",
  "about": "string",
  "country": "string",
  "gender": "string", // 'm' for male, 'f' for female
  "imagePath": "string",
  "followers": "number",
  "following": ["userId1", "userId2", ...],
  "privateLibrary": ["trackId1", "trackId2", ...],
  "publicLibrary": ["trackId1", "trackId2", ...],
  "isVerified": "boolean",
  "timestamp": "timestamp"
}
```

**Example Document**:
```json
{
  "uid": "abc123def456",
  "email": "user@example.com",
  "name": "Ahmed Hassan",
  "about": "Quran reciter from Egypt",
  "country": "Egypt",
  "gender": "m",
  "imagePath": "https://firebasestorage.googleapis.com/.../profile.jpg",
  "followers": 1250,
  "following": ["user456", "user789"],
  "privateLibrary": ["track001", "track002"],
  "publicLibrary": ["track003", "track004", "track005"],
  "isVerified": true,
  "timestamp": "2024-12-19T10:30:00Z"
}
```

**Indexes**:
- `gender` (for gender-based filtering)
- `followers` (for popularity sorting)
- `timestamp` (for chronological ordering)

### 2. QawlTracks Collection

**Collection Path**: `QawlTracks/{trackId}`

**Document Structure**:
```json
{
  "userId": "string", // Reference to QawlUsers collection
  "trackName": "string",
  "style": "string", // e.g., "Hafs 'an Asim", "Warsh 'an Nafi"
  "surahNumber": "number",
  "plays": "number",
  "audioPath": "string", // Firebase Storage URL
  "coverImagePath": "string",
  "timeStamp": "timestamp",
  "inPlaylists": ["playlistId1", "playlistId2", ...]
}
```

**Example Document**:
```json
{
  "userId": "abc123def456",
  "trackName": "Al-Fatiha - Hafs 'an Asim",
  "style": "Hafs 'an Asim",
  "surahNumber": 1,
  "plays": 15420,
  "audioPath": "https://firebasestorage.googleapis.com/.../audio.mp3",
  "coverImagePath": "https://firebasestorage.googleapis.com/.../cover.jpg",
  "timeStamp": "2024-12-19T10:30:00Z",
  "inPlaylists": ["playlist001", "playlist002"]
}
```

**Indexes**:
- `plays` (for popularity sorting)
- `timeStamp` (for new releases filtering)
- `style` (for style-based filtering)
- `surahNumber` (for surah-based queries)
- `userId` (for user's uploads)

### 3. QawlPlaylists Collection

**Collection Path**: `QawlPlaylists/{playlistId}`

**Document Structure**:
```json
{
  "author": "string", // User ID reference
  "name": "string",
  "description": "string",
  "isPublic": "boolean",
  "tracks": ["trackId1", "trackId2", ...],
  "createdAt": "timestamp",
  "updatedAt": "timestamp",
  "playCount": "number"
}
```

**Example Document**:
```json
{
  "author": "abc123def456",
  "name": "My Favorite Recitations",
  "description": "Collection of my favorite Quran recitations",
  "isPublic": true,
  "tracks": ["track001", "track002", "track003"],
  "createdAt": "2024-12-19T10:30:00Z",
  "updatedAt": "2024-12-19T15:45:00Z",
  "playCount": 1250
}
```

**Indexes**:
- `author` (for user's playlists)
- `isPublic` (for public/private filtering)
- `createdAt` (for chronological ordering)
- `playCount` (for popularity sorting)

## Model Relationships

### 1. User-Track Relationship (One-to-Many)

**Relationship Type**: One user can upload many tracks

**Database Implementation**:
```javascript
// Query: Get all tracks by a specific user
const userTracks = await FirebaseFirestore.instance
  .collection('QawlTracks')
  .where('userId', isEqualTo: 'abc123def456')
  .orderBy('timeStamp', descending: true)
  .get();
```

**Example Query Results**:
```json
[
  {
    "id": "track001",
    "userId": "abc123def456",
    "trackName": "Al-Fatiha",
    "surahNumber": 1,
    "plays": 15420
  },
  {
    "id": "track002", 
    "userId": "abc123def456",
    "trackName": "Al-Baqarah",
    "surahNumber": 2,
    "plays": 8920
  }
]
```

### 2. User-Playlist Relationship (One-to-Many)

**Relationship Type**: One user can create many playlists

**Database Implementation**:
```javascript
// Query: Get all playlists by a specific user
const userPlaylists = await FirebaseFirestore.instance
  .collection('QawlPlaylists')
  .where('author', isEqualTo: 'abc123def456')
  .orderBy('createdAt', descending: true)
  .get();
```

### 3. Playlist-Track Relationship (Many-to-Many)

**Relationship Type**: Many playlists can contain many tracks

**Database Implementation**:
```javascript
// Query: Get all tracks in a specific playlist
const playlistDoc = await FirebaseFirestore.instance
  .collection('QawlPlaylists')
  .doc('playlist001')
  .get();

const trackIds = playlistDoc.data()['tracks'];
const tracks = await FirebaseFirestore.instance
  .collection('QawlTracks')
  .where(FieldPath.documentId(), whereIn: trackIds)
  .get();
```

### 4. User-User Relationship (Many-to-Many)

**Relationship Type**: Users can follow many other users

**Database Implementation**:
```javascript
// Query: Get all users that a specific user follows
const userDoc = await FirebaseFirestore.instance
  .collection('QawlUsers')
  .doc('abc123def456')
  .get();

const followingIds = userDoc.data()['following'];
const followingUsers = await FirebaseFirestore.instance
  .collection('QawlUsers')
  .where(FieldPath.documentId(), whereIn: followingIds)
  .get();
```

## Complex Queries & Use Cases

### 1. Gender-Based Content Filtering

**Use Case**: Filter tracks based on user's gender preference

**Query**:
```javascript
// Get male users
const maleUsers = await FirebaseFirestore.instance
  .collection('QawlUsers')
  .where('gender', isEqualTo: 'm')
  .get();

const maleUserIds = maleUsers.docs.map(doc => doc.id);

// Get tracks by male users
const maleUserTracks = await FirebaseFirestore.instance
  .collection('QawlTracks')
  .where('userId', whereIn: maleUserIds)
  .orderBy('plays', descending: true)
  .limit(100)
  .get();
```

### 2. New Releases Query

**Use Case**: Get tracks uploaded in the last 28 days

**Query**:
```javascript
const threeWeeksAgo = DateTime.now().subtract(Duration(days: 28));

const newReleases = await FirebaseFirestore.instance
  .collection('QawlTracks')
  .where('timeStamp', isGreaterThan: threeWeeksAgo)
  .orderBy('timeStamp', descending: true)
  .limit(100)
  .get();
```

### 3. Top 100 Tracks

**Use Case**: Get most played tracks

**Query**:
```javascript
const topTracks = await FirebaseFirestore.instance
  .collection('QawlTracks')
  .orderBy('plays', descending: true)
  .limit(100)
  .get();
```

### 4. User's Library Management

**Use Case**: Get user's private and public library

**Query**:
```javascript
const userDoc = await FirebaseFirestore.instance
  .collection('QawlUsers')
  .doc('abc123def456')
  .get();

const privateLibraryIds = userDoc.data()['privateLibrary'];
const publicLibraryIds = userDoc.data()['publicLibrary'];

// Get private library tracks
const privateTracks = await FirebaseFirestore.instance
  .collection('QawlTracks')
  .where(FieldPath.documentId(), whereIn: privateLibraryIds)
  .get();

// Get public library tracks  
const publicTracks = await FirebaseFirestore.instance
  .collection('QawlTracks')
  .where(FieldPath.documentId(), whereIn: publicLibraryIds)
  .get();
```

## Data Consistency Patterns

### 1. Denormalization Strategy

**Approach**: Store frequently accessed data in multiple places

**Example**: Track count in playlists
```json
// Playlist document includes track count
{
  "name": "My Playlist",
  "tracks": ["track001", "track002", "track003"],
  "trackCount": 3  // Denormalized for quick access
}
```

### 2. Reference Integrity

**Approach**: Use document references for relationships

**Example**: Track references in playlists
```json
// Playlist document with track references
{
  "name": "Favorites",
  "tracks": ["track001", "track002"], // Array of track IDs
  "author": "user123" // Reference to user
}
```

### 3. Atomic Updates

**Approach**: Use transactions for related updates

**Example**: Following a user
```javascript
await FirebaseFirestore.instance.runTransaction((transaction) async {
  // Update follower's following list
  const followerRef = FirebaseFirestore.instance
    .collection('QawlUsers')
    .doc('followerId');
  
  const followerDoc = await transaction.get(followerRef);
  const following = followerDoc.data()['following'] || [];
  following.add('followedUserId');
  
  transaction.update(followerRef, {'following': following});
  
  // Update followed user's follower count
  const followedRef = FirebaseFirestore.instance
    .collection('QawlUsers')
    .doc('followedUserId');
  
  const followedDoc = await transaction.get(followedRef);
  const followers = followedDoc.data()['followers'] || 0;
  
  transaction.update(followedRef, {'followers': followers + 1});
});
```

## Performance Considerations

### 1. Indexing Strategy

**Composite Indexes**:
- `userId + timeStamp` (for user's uploads)
- `style + plays` (for style-based popularity)
- `gender + plays` (for gender-based popularity)

### 2. Query Optimization

**Pagination**:
```javascript
// Use cursor-based pagination
const lastDoc = // ... last document from previous query
const nextPage = await FirebaseFirestore.instance
  .collection('QawlTracks')
  .orderBy('plays', descending: true)
  .startAfterDocument(lastDoc)
  .limit(20)
  .get();
```

### 3. Caching Strategy

**Client-Side Caching**:
- Cache frequently accessed user data
- Cache playlist contents
- Cache search results

## Security Rules Considerations

### 1. User Data Access
```javascript
// Users can read their own data and public user data
match /QawlUsers/{userId} {
  allow read: if request.auth != null && 
    (request.auth.uid == userId || resource.data.isPublic == true);
  allow write: if request.auth != null && request.auth.uid == userId;
}
```

### 2. Track Access
```javascript
// Users can read all tracks, write only their own
match /QawlTracks/{trackId} {
  allow read: if request.auth != null;
  allow write: if request.auth != null && 
    request.auth.uid == resource.data.userId;
}
```

### 3. Playlist Access
```javascript
// Users can read public playlists, write their own
match /QawlPlaylists/{playlistId} {
  allow read: if request.auth != null && 
    (resource.data.isPublic == true || resource.data.author == request.auth.uid);
  allow write: if request.auth != null && 
    resource.data.author == request.auth.uid;
}
```

## Migration & Versioning

### 1. Schema Evolution
- Add new fields with default values
- Use optional fields for backward compatibility
- Version documents with schema version field

### 2. Data Migration
```javascript
// Example: Adding new field to existing documents
const users = await FirebaseFirestore.instance
  .collection('QawlUsers')
  .get();

const batch = FirebaseFirestore.instance.batch();
users.docs.forEach((doc) => {
  if (!doc.data().hasOwnProperty('isVerified')) {
    batch.update(doc.ref, {'isVerified': false});
  }
});
await batch.commit();
```

This document provides a comprehensive overview of the data models, their relationships, and database patterns used in the Qawl application. 